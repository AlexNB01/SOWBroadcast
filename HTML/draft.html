<!DOCTYPE html>
<html lang="fi">
<head>
<meta charset="utf-8"/>
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/>
<meta http-equiv="Pragma" content="no-cache"/>
<meta http-equiv="Expires" content="0"/>
<title>Draft</title>

<style>
  /* ==== Fonts (sama kuin singlecam) ==== */
  @font-face{font-family:'Rajdhani';src:url("fonts/Rajdhani/Rajdhani-Bold.ttf") format('TrueType');font-weight:bold}
  @font-face{font-family:'Rajdhani';src:url("fonts/Rajdhani/Rajdhani-Regular.ttf") format('TrueType');font-weight:normal}

  /* ==== Base ==== */
	html,body{
	  margin:0; padding:0; width:1920px; height:1080px; overflow:hidden;
	  font-family:'Rajdhani',system-ui,-apple-system,'Segoe UI',Roboto,Arial,sans-serif;
	  font-weight:800; text-transform:uppercase;
	  -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
	}
  :root{
    --primary:#0f1114; --secondary:#ffffff; --tertiary:#3a3a90; --quaternary:#006ea1;
    --t1:#27AAE1; --t2:#C80013;
    --radius:12px; --radius-sm:8px; --gap:16px;
    --shadow:0 8px 22px rgba(0,0,0,.25);
    --sb-w:1620px; --sb-h:100px;
  }

  /* ==== SCOREBOARD (singlecam-look) ==== */
.scoreboardwrapper{
  position:absolute; left:0; top:0; width:1920px; height:var(--sb-h);
  display:flex; align-items:center; justify-content:center; pointer-events:none;
}

.scorebar{
  width:1920px; height:var(--sb-h);
  background:var(--primary); color:var(--tertiary);
  border-radius:0;                 /* ei pyöristyksiä = ei gappeja */
  box-shadow:none;                 /* ei varjoa = tasainen reuna */
  position:relative;
  display:grid; grid-template-columns:1fr auto 1fr;
  align-items:center; padding:0 16px;
}
.scorebar::before, .scorebar::after{
  content:""; position:absolute; top:0; bottom:0; width:8px;
}
.scorebar::before{ left:0;  background:var(--t1); border-radius:0; }
.scorebar::after { right:0; background:var(--t2); border-radius:0; }

  .team{ height:100%; display:flex; align-items:center; gap:16px; }
  .team2{ flex-direction:row-reverse; }
  .teamlogo{
    width:90px; height:90%; border-radius:var(--radius-sm);
    background-size:contain; background-position:center; background-repeat:no-repeat;
  }
  .teamname{
    flex:1 1 auto; font-weight:900; font-size:68px; letter-spacing:.5px;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis; color:var(--secondary); text-align:center;
  }
  .scorebox{
    flex:0 0 105px; height:100%; display:flex; align-items:center; justify-content:center;
    background:var(--quaternary);
  }
  .teamscore{ font-size:68px; font-weight:900; line-height:1; color:#ffffff; }
  .vs{
    height:100%; display:flex; align-items:center; justify-content:center;
    padding:0 30px; background:var(--tertiary); color:var(--primary);
    font-size:68px; font-weight:900;
  }

  /* ==== DRAFT-ALUE ==== */
.draft-area{
  position:absolute; left:0; top:var(--sb-h);
  width:1920px; bottom:20px;
  display:grid;
  grid-auto-flow:column;
  grid-template-columns: repeat(auto-fit, minmax(0,1fr));
  gap:16px; padding:0 24px; box-sizing:border-box;
  margin-top:20px;
}

  .col{ display:flex; flex-direction:column; gap:12px; }
/* Uusi header container taustalla */
.mode-header {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  padding: 8px 0;
  color: var(--primary);
  font-size: 22px;
  letter-spacing: .5px;
  text-shadow: 0 0 6px rgba(0,0,0,.35);
  text-align: center;

  /* uusi tausta */
  background: #1e2b38;
  border-top: 2px solid #0f1a24;
  border-bottom: 2px solid #0f1a24;
  position: relative;
}

/* erotusviivat pystysuunnassa */
.mode-column {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
  border-left: 2px solid #1db954;  /* vihreä erotusviiva */
}

.mode-column:first-child {
  border-left: none; /* ensimmäisessä ei vasemman reunan viivaa */
}

.mode-header img {
  height: 26px;
  filter: drop-shadow(0 0 6px rgba(0,0,0,.5));
}

.map-card{
  position:relative;
  height:var(--card-h, 200px);
  border-radius:var(--radius);
  background-size:cover;
  background-position:center;
  box-shadow:var(--shadow);

  /* Reunavuodon estot */
  overflow:hidden;                 /* leikkaa kaikki sisällöt reunan sisään */
  background-clip:padding-box;     /* tausta ei piirry “borderin alle” */
  isolation:isolate;               /* lapsivarjot eivät vuoda ulos */

  /* Fokusreunaa varten pidetään border, mutta klipataan oikein */
}

  /* KOKO LEVYINEN NIMITANKO */
.map-card.winner-t1::before,
.map-card.winner-t2::before{
  content:"";
  position:absolute; inset:0;
  border-radius:inherit;                 /* ← tärkeä */
  background: linear-gradient(
    0deg,
    rgba(var(--winner-rgb), .75) 0%,
    rgba(var(--winner-rgb), .55) 55%,
    rgba(var(--winner-rgb), 0) 100%
  );
  pointer-events:none;
}

.winner-center{ position:absolute; inset:0; border-radius:inherit; /* ← */ 
  display:flex; align-items:center; justify-content:center; pointer-events:none;
}

.map-card .map-name{
  position:absolute; left:0; right:0; bottom:0;
  background:rgba(0,0,0,.70);
  color:#fff; padding:10px 16px;
  border-radius:0 0 calc(var(--radius) - 4px) calc(var(--radius) - 4px); /* sovita borderiin */
  font-size:22px; font-weight:900; text-align:center;
  letter-spacing:.4px; text-shadow:0 0 6px rgba(0,0,0,.8);
}

  .winner-center{
    position:absolute; inset:0;
    display:flex; align-items:center; justify-content:center;
    pointer-events:none;
  }
  .winner-center img{
    width:60%; max-width:320px; max-height:70%; margin-bottom:50px;
    object-fit:contain; filter:drop-shadow(0 8px 18px rgba(0,0,0,.55));
    opacity:.95;
  }

  /* PICK-badge: valkoinen lätkä keskellä alhaalla (muutettu .badge-tyyli pyyntösi mukaan) */
  .badge{
    position:absolute; display:flex; align-items:center; gap:8px;
    padding:0; margin:0; border:0;
    pointer-events:none; /* estä osumat OBS:ssa */
  }
  .badge.pick{
    bottom:56px; left:50%; transform:translateX(-50%);
    background:#ffffff; color:#111; border-radius:12px;
    padding:8px 8px; gap:8px; box-shadow:0 6px 16px rgba(0,0,0,.35);
    font-weight:900;
  }
  .badge.pick img{ width:30px; height:30px; border-radius:4px; }

  /* Fokus valitulle kartalle: reunus + nimitangon väri tiimin mukaan */
  .map-card.picked-t1{ border-color:var(--t1); box-shadow:0 10px 26px rgba(0,0,0,.35); }
  .map-card.picked-t2{ border-color:var(--t2); box-shadow:0 10px 26px rgba(0,0,0,.35); }
  .map-card.picked-t1 .map-name{ background:rgba(var(--t1-rgb), .85); }
  .map-card.picked-t2 .map-name{ background:rgba(var(--t2-rgb), .85); }

  .empty-note{ grid-column:1 / -1; color:#ddd; font-size:22px; opacity:.9; margin:16px 8px; }
  
  /* Poista tumma tausta, kun kartta on pelattu */
.map-card.winner-t1 .map-name,
.map-card.winner-t2 .map-name {
  background: none !important;    /* poistaa palkin */
  text-shadow: 0 0 8px rgba(0,0,0,.7); /* lisätään vähän kontrastia */
}
.map-card.disabled { filter: grayscale(60%) brightness(60%); }

.corner-ban{
  position:absolute;
  bottom:22px;
  width:220px; height:220px;
  display:flex; align-items:flex-end; justify-content:center;
  pointer-events:none; z-index:50;
  /* lasimainen tausta nimen ‘chipille’ */
}
.corner-ban.left  { left:22px; }
.corner-ban.right { right:22px; }

.corner-ring{
  position:absolute; inset:0;
  border-radius:24px;
  background:linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,.65));
  border:4px solid rgba(255,255,255,.12);
  box-shadow:0 12px 28px rgba(0,0,0,.35), inset 0 0 0 2px rgba(255,255,255,.06);
}

.corner-ring.t1{ outline:4px solid var(--t1); outline-offset:-6px; }
.corner-ring.t2{ outline:4px solid var(--t2); outline-offset:-6px; }

.corner-hero{
  position:absolute; inset:10px;
  border-radius:18px;
  background:#ffffff center/contain no-repeat;
  filter:drop-shadow(0 12px 24px rgba(0,0,0,.45));
}

.corner-chip{
  position:relative; bottom:10px;
  max-width:92%;
  padding:8px 12px; border-radius:999px;
  color:#fff; font-size:18px; font-weight:900; letter-spacing:.4px;
  background:rgba(20,20,20,.55);
  border:1px solid rgba(255,255,255,.12);
  backdrop-filter:blur(6px);
  text-shadow:0 2px 6px rgba(0,0,0,.6);
}

.corner-chip.t1 { box-shadow:0 0 0 2px var(--t1); }
.corner-chip.t2 { box-shadow:0 0 0 2px var(--t2); }
.status-wrapper{
  position:absolute; left:0; bottom:6%; width:100%;
  display:flex; align-items:center; justify-content:center;
}

.statusiso{
  background:var(--primary);
  border-left:8px solid var(--tertiary);
  border-right:8px solid var(--tertiary);
  border-radius:12px;
  box-shadow:0 8px 22px rgba(0,0,0,.25);
  display:flex; align-items:center; justify-content:center;
  min-width:400px; max-width:75%;
  height:70px;
}

.status{
  display:flex; align-items:center; justify-content:center;
  padding:0 24px;
}

.statusname{
  font-size:40px; letter-spacing:.6px;
  color:var(--secondary);
  text-transform:uppercase;
  font-weight:800;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}


</style>
</head>
<body>

<!-- SCOREBOARD -->
<div class="scoreboardwrapper">
  <div class="scorebar">
    <div class="team team1">
      <div class="teamlogo" id="t1logo"></div>
      <div class="teamname" id="t1name">TEAM 1</div>
      <div class="scorebox" id="t1scorebox"><span class="teamscore" id="t1score">0</span></div>
    </div>
    <div class="vs">VS</div>
    <div class="team team2">
      <div class="teamlogo" id="t2logo"></div>
      <div class="teamname" id="t2name">TEAM 2</div>
      <div class="scorebox" id="t2scorebox"><span class="teamscore" id="t2score">0</span></div>
    </div>
  </div>
</div>

<!-- DRAFT COLUMNS -->
<div class="draft-area" id="draftArea"></div>
<!-- Corner bans -->
<div id="banLeft"  class="corner-ban left"  aria-hidden="true"></div>
<div id="banRight" class="corner-ban right" aria-hidden="true"></div>
<div class="status-wrapper">
  <div class="statusiso" id="status-bar" style="display:none">
    <div class="status">
      <span class="statusname" id="status-text"></span>
    </div>
  </div>
</div>



<script>
/* ----- Polut ja helperit ----- */
const ROOT="..", SB=ROOT+"/Scoreboard", MATCH=SB+"/Match", GENERAL=SB+"/General";
async function read(p){ try{ const r=await fetch(p+"?_="+Date.now()); return r.ok?await r.text():""; }catch{ return ""; } }
async function readJSON(p){ try{ const r=await fetch(p+"?_="+Date.now()); return r.ok?await r.json():{}; }catch{ return {}; } }
async function ok(p){ try{ const r=await fetch(p+"?_="+Date.now(),{method:"HEAD"}); return r.ok; }catch{ return false; } }
const hex=s=>/^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test((s||"").trim())?(s||"").trim():null;
const setBg=(el,url)=>el&&(el.style.backgroundImage=`url('${url}?_=${Date.now()}')`);
const bySlug=list=>{const m={};(list||[]).forEach(x=>x?.slug&&(m[x.slug]=x));return m;};
const nameToSlug=n=> (n||"").normalize("NFKD").replace(/[\u0300-\u036f]/g,"").toLowerCase()
  .replace(/[^a-z0-9]+/g,"-").replace(/-+/g,"-").replace(/^-|-$/g,"");
function hexToRgb(hexStr){
  const m=(hexStr||"").trim().replace(/^#/,'').toLowerCase();
  const s=m.length===3?m.split('').map(c=>c+c).join(''):m;
  const n=parseInt(s,16); if(isNaN(n)||s.length!==6) return null;
  return [(n>>16)&255,(n>>8)&255,n&255];
}

// pienen apurin voi jakaa
const heroSlug = (name) =>
  (name||"").normalize("NFKD").replace(/[\u0300-\u036f]/g,"")
    .toLowerCase().replace(/[^a-z0-9]+/g,"-").replace(/-+/g,"-").replace(/^-|-$/g,"");

async function readMapBansByIndex(n){
  if(!n || n < 1) return {t1_ban:"", t2_ban:""};
  const path = `${MATCH}/Map${n}.txt`;
  try{
    const r = await fetch(path + "?_=" + Date.now());
    if(!r.ok) return {t1_ban:"", t2_ban:""};
    const kv = {};
    (await r.text()).split(/\r?\n/).forEach(line=>{
      const m = line.match(/^\s*([^=#]+)\s*=\s*(.+?)\s*$/);
      if(m) kv[m[1].trim()] = m[2].trim();
    });
    return {
      t1_ban: (kv.T1Ban || "").trim(),
      t2_ban: (kv.T2Ban || "").trim(),
    };
  }catch{ return {t1_ban:"", t2_ban:""}; }
}


function cornerBanHTML(side, hero){
  if(!hero) return "";
  const slug = heroSlug(hero);
  const img  = slug ? `${SB}/Heroes/${slug}.png` : ""; // EI Date.now -> ei vilku
  return `
    <div class="corner-ring ${side}"></div>
    <div class="corner-hero" style="${img ? `background-image:url('${img}')` : ""}"></div>
  `;
}

let _prevCorner = { b1: null, b2: null };

async function upStatusText(){
  const txt = await read(MATCH + "/status.txt");
  const s = (txt || "").trim();
  const bar = document.getElementById("status-bar");
  const span = document.getElementById("status-text");
  if (!bar || !span) return;

  if (s){
    span.textContent = s.toUpperCase();
    bar.style.display = "flex";
  } else {
    span.textContent = "";
    bar.style.display = "none";
  }
}

async function renderCornerBans(state){
  // 1) Current map index: match.json -> fallback CurrentMap.txt
  let ci = Number(state.current || 0);
  if(!ci){
    const ctxt = (await read(MATCH + "/CurrentMap.txt")).trim();
    ci = parseInt(ctxt, 10) || 0;
  }
  const idx = ci > 0 ? (ci - 1) : -1;

  // 2) Lähde 1: match.json → t1_ban/t2_ban
  let b1 = "", b2 = "";
  const cur = (idx >= 0 && (state.maps||[])[idx]) ? state.maps[idx] : null;
  if(cur){
    b1 = (cur.t1_ban || "").trim();
    b2 = (cur.t2_ban || "").trim();
  }

  // 3) Fallback: MapN.txt, jos match.json ei vielä sisällä ban-kenttiä
  if(!b1 && !b2 && ci > 0){
    const fb = await readMapBansByIndex(ci);
    b1 = fb.t1_ban || "";
    b2 = fb.t2_ban || "";
  }

  // 4) Päivitä DOM vain jos muuttui (välttää vilkkumisen)
  if(b1 !== _prevCorner.b1){
    const el = document.getElementById("banLeft");
    el.innerHTML   = b1 ? cornerBanHTML("t1", b1) : "";
    el.style.display = b1 ? "block" : "none";
    _prevCorner.b1 = b1;
  }
  if(b2 !== _prevCorner.b2){
    const el = document.getElementById("banRight");
    el.innerHTML   = b2 ? cornerBanHTML("t2", b2) : "";
    el.style.display = b2 ? "block" : "none";
    _prevCorner.b2 = b2;
  }
}


/* ----- Värit General/colors.txt:stä ----- */
async function applyColors(){
  const kv={};
  (await read(GENERAL+"/colors.txt")).split(/\r?\n/).forEach(l=>{
    const m=l.match(/^\s*([^=#]+)\s*=\s*(.+?)\s*$/); if(m) kv[m[1].trim()]=m[2].trim();
  });
  const p=hex(kv.primary)||"#0f1114", s=hex(kv.secondary)||"#ffffff", t=hex(kv.tertiary)||"#3a3a90", q=hex(kv.quaternary)||"#006ea1";
  document.documentElement.style.setProperty("--primary",p);
  document.documentElement.style.setProperty("--secondary",s);
  document.documentElement.style.setProperty("--tertiary",t);
  document.documentElement.style.setProperty("--quaternary",q);
}

/* ----- Tiimit (singlecam-logiikka + RGB:t voittajaliukua varten) ----- */
async function upT1(){
  document.getElementById("t1name").textContent=((await read(MATCH+"/T1Name.txt")).trim()||"TEAM 1").toUpperCase();
  document.getElementById("t1score").textContent=(await read(MATCH+"/T1Score.txt")).trim()||"0";
  const c = hex((await read(MATCH+"/T1Color.txt")).trim()) || "#27AAE1";
  document.documentElement.style.setProperty("--t1", c);
  const rgb = hexToRgb(c) || [39,170,225];
  document.documentElement.style.setProperty("--t1-rgb", rgb.join(","));
  if(await ok(MATCH+"/T1Logo.png")) setBg(document.getElementById("t1logo"), MATCH+"/T1Logo.png");
  else document.getElementById("t1logo").style.backgroundImage="none";
}
async function upT2(){
  document.getElementById("t2name").textContent=((await read(MATCH+"/T2Name.txt")).trim()||"TEAM 2").toUpperCase();
  document.getElementById("t2score").textContent=(await read(MATCH+"/T2Score.txt")).trim()||"0";
  const c = hex((await read(MATCH+"/T2Color.txt")).trim()) || "#C80013";
  document.documentElement.style.setProperty("--t2", c);
  const rgb = hexToRgb(c) || [200,0,19];
  document.documentElement.style.setProperty("--t2-rgb", rgb.join(","));
  if(await ok(MATCH+"/T2Logo.png")) setBg(document.getElementById("t2logo"), MATCH+"/T2Logo.png");
  else document.getElementById("t2logo").style.backgroundImage="none";
}
function toggleScoreBoxes(){
  const a=(document.getElementById("t1score").textContent||"0").trim();
  const b=(document.getElementById("t2score").textContent||"0").trim();
  const show=(parseInt(a,10)||0)!==0 || (parseInt(b,10)||0)!==0;
  document.getElementById("t1scorebox").style.display=show?"flex":"none";
  document.getElementById("t2scorebox").style.display=show?"flex":"none";
}

/* ----- Draftin renderöinti sarakkeisiin (modes manifestista) ----- */
async function renderDraft(){
  const state = await readJSON(MATCH + "/match.json");

  const T1A = (state.team1?.abbr || state.team1?.name || "T1").toUpperCase();
  const T2A = (state.team2?.abbr || state.team2?.name || "T2").toUpperCase();

  // pool (slug.png)
  const files = (await read(MATCH + "/maps.txt")).split(/\r?\n/).filter(Boolean);

  // manifestit
  const mapsManifest  = await readJSON(SB + "/Maps/index.json");      // {maps:[{name,slug,mode}]}
  const modesManifest = await readJSON(SB + "/Gametypes/index.json"); // {modes:[{name,slug}]}
  const mapsBySlug = bySlug(mapsManifest.maps || []);
  const modes = (modesManifest.modes || []).slice().sort((a,b)=>(a.name||"").localeCompare(b.name||""));

  // pelatut & voittajat & pick
  const played  = new Set((state.maps||[]).filter(m => m.completed).map(m => m.map));
  const winners = Object.fromEntries((state.maps||[]).map(m => [m.map, (""+m.winner).toLowerCase()]));   // "t1"/"t2"/""
  const picksRaw= Object.fromEntries((state.maps||[]).map(m => [m.map, (m.pick||"")])); // "T1"/"T2"/"Team 1"/"Team 2"
  const picks   = {};
  Object.keys(picksRaw).forEach(k=>{
    let v = (""+picksRaw[k]).toUpperCase();
    if(v==="TEAM 1") v="T1"; if(v==="TEAM 2") v="T2";
    picks[k]=v;
  });
  
// mikä kartta on pickattu / valittuna missäkin modessa?
const pickedByMode = {};
(state.maps || []).forEach(m => {
  const hasPick = ("" + (m.pick || "")).trim() !== "";
  if (!hasPick) return;
  const mk = ((m.mode || (mapsBySlug[nameToSlug(m.map)]?.mode) || "") + "").toLowerCase();
  if (mk) pickedByMode[mk] = nameToSlug(m.map);   // <-- SLUG talteen
});

// Lisäksi: jos GUIn "NOW PICK" on vain current-indeksissä
const ci = Number(state.current || 0) - 1;
if (ci >= 0 && (state.maps || [])[ci]) {
  const cur = state.maps[ci];
  if (!cur.completed) {
    const mk = ((cur.mode || (mapsBySlug[nameToSlug(cur.map)]?.mode) || "") + "").toLowerCase();
    if (mk && !pickedByMode[mk]) pickedByMode[mk] = nameToSlug(cur.map); // <-- SLUG
  }
}

  // saatavuuslogiikka: modet kerrallaan → kaikki auki kun kaikki käytetty
  const completed = new Set((state.maps||[]).filter(m=>m.completed).map(m=>{
    const meta = mapsBySlug[nameToSlug(m.map)];
    return ((m.mode || (meta?.mode) || "") + "").toLowerCase();
  }));
  const allModeKeys = modes.map(m=>(m.name||"").toLowerCase());
  const available = (completed.size===modes.length)
      ? new Set(allModeKeys)
      : new Set(allModeKeys.filter(x=>!completed.has(x)));

  // rakenna sarakkeet kaikille modeille dynaamisesti ja skaalaa leveys modien määrän mukaan
  const root = document.getElementById("draftArea");
  root.style.gridTemplateColumns = `repeat(${Math.max(1, modes.length)}, 1fr)`;
  root.innerHTML = "";

  modes.forEach(mm=>{
    const modeKey=(mm.name||"").toLowerCase();
    const col=document.createElement("div"); col.className="col";

    // otsikko + ikoni
    const h=document.createElement("div"); h.className="mode-header";
    if(mm.slug){ const i=document.createElement("img"); i.src=`${SB}/Gametypes/${mm.slug}.png?_=${Date.now()}`; i.alt=mm.name; h.appendChild(i); }
    const lbl=document.createElement("div"); lbl.textContent=(mm.name||modeKey).toUpperCase();
    h.appendChild(lbl);
    col.appendChild(h);

    // kortit (vain poolista ja oikean moden mukaan)
    files.forEach(file=>{
      const slug=file.replace(/\.(png|jpg|jpeg|webp)$/i,"");
      const meta=mapsBySlug[slug]; if(!meta) return;
      if((meta.mode||"").toLowerCase()!==modeKey) return;

      const card=document.createElement("div");
      card.className="map-card";
      card.style.backgroundImage=`url('${SB}/Maps/${file}?_=${Date.now()}')`;
      card.innerHTML=`<div class="map-name">${meta.name}</div>`;

      // ÄLÄ harmaannuta pelattuja: disabled vain jos EI pelattu JA mode ei ole tällä hetkellä valittavissa
      // 1) Pelattuja EI harmaanneta
		const thisSlug = slug;

		// 1) Pelattuja EI harmaanneta
		let disable = false;

		if (!played.has(meta.name)) {
		  const pickedSlugInThisMode = pickedByMode[modeKey];
		  const isPickedHere = pickedSlugInThisMode && pickedSlugInThisMode === thisSlug;

		  if (pickedSlugInThisMode) {
			// Jos jokin on pickattu tässä modessa, harmaannutetaan vain MUUT kartat
			disable = !isPickedHere;
		  } else {
			// Ei pickkiä tässä modessa: harmaanna jos mode ei ole nyt käytettävissä
			disable = !available.has(modeKey);
		  }
		}

		if (disable) card.classList.add("disabled");

      // VOITTAJA: liukuväri + keskitetty logo
      const w = winners[meta.name]; // "t1"/"t2"
      if(w==="t1" || w==="t2"){
        const rgbVar = getComputedStyle(document.documentElement)
                         .getPropertyValue(w==="t1" ? "--t1-rgb" : "--t2-rgb").trim() || "255,255,255";
        card.style.setProperty("--winner-rgb", rgbVar);

        const center = document.createElement("div");
        center.className = "winner-center";
        const img = document.createElement("img");
        img.src = `${MATCH}/${w.toUpperCase()}Logo.png?_=${Date.now()}`; // T1Logo/T2Logo
        img.alt = w.toUpperCase();
        center.appendChild(img);
        card.appendChild(center);

        card.classList.add(w==="t1" ? "winner-t1" : "winner-t2");
      }

      // PICK-badge: logo + abbr + "PICK" – mutta älä näytä jos kartta on jo pelattu (winner näkyy)
      const p = (picks[meta.name]||"").toUpperCase(); // "T1"/"T2"
      if((p==="T1" || p==="T2") && !(w==="t1" || w==="t2")){
        const b=document.createElement("div");
        b.className="badge pick";
        const img=document.createElement("img");
        img.src=`${MATCH}/${p}Logo.png?_=${Date.now()}`; // T1Logo/T2Logo
        img.alt=p;
        b.appendChild(img);
        const txt=document.createElement("span");
        const abbr = p==="T1" ? T1A : T2A;
        txt.textContent = `${abbr} PICK`;
        b.appendChild(txt);
        card.appendChild(b);

        // fokus-efekti valitulle kartalle
        card.classList.add(p==="T1" ? "picked-t1" : "picked-t2");
      }

      col.appendChild(card);
    });
	const count = col.querySelectorAll('.map-card').length;
	const GAP = 12;           // vastaa .col { gap:12px; }
	const BASE = 200;         // peruskortin korkeus
	const TOTAL = 3*BASE + 2*GAP;
	const perCard = count > 0 ? (TOTAL - (count-1)*GAP) / count : BASE;
	col.style.setProperty('--card-h', `${Math.max(120, perCard)}px`);
    root.appendChild(col);
  });
}

/* ----- Kevyt vahti: reagoi pooliin, tiimitiedostoihin JA match.json/maps-muutoksiin ----- */
let _prevSig=null;
async function tick(){
  try{
    const [pool, t1n,t2n,t1s,t2s,t1c,t2c, state] = await Promise.all([
      read(MATCH+"/maps.txt"),
      read(MATCH+"/T1Name.txt"), read(MATCH+"/T2Name.txt"),
      read(MATCH+"/T1Score.txt"), read(MATCH+"/T2Score.txt"),
      read(MATCH+"/T1Color.txt"), read(MATCH+"/T2Color.txt"),
      readJSON(MATCH+"/match.json"),
    ]);

    // Ota bannit talteen
    const b1 = (state.team1?.banned_hero || "").trim();
    const b2 = (state.team2?.banned_hero || "").trim();

    // tiivis allekirjoitus: pool + tiimit + olennaiset tiedot
    const mapsSig = JSON.stringify((state.maps||[]).map(m=>({
      map:m.map, completed:!!m.completed, winner:(m.winner||""), pick:(m.pick||""), mode:(m.mode||"")
    })));
    const bansSig = JSON.stringify((state.maps||[]).map(m=>[m.t1_ban||"", m.t2_ban||""]));
	const sig = [pool,t1n,t2n,t1s,t2s,t1c,t2c,mapsSig,bansSig].join("|");


    if(sig!==_prevSig){
      _prevSig=sig;
      await applyColors();
      await Promise.all([upT1(), upT2()]);
      toggleScoreBoxes();
      await renderDraft();
    }
	upStatusText().catch(()=>{});
    // Päivitä bannit joka kierroksella
    await renderCornerBans(state);

  }finally{
    setTimeout(tick, 1000);
  }
}


tick();
</script>
</body>
</html>
